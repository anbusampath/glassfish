/*
 * Copyright (c) 2023 Contributors to the Eclipse Foundation
 * Copyright (c) 2008, 2020 Oracle and/or its affiliates. All rights reserved.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0, which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the
 * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,
 * version 2 with the GNU Classpath Exception, which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 */

//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation,
// v2.1.3-04/12/2007 12:08 AM(kohsuke)-fcs
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source schema.
// Generated on: 2007.08.24 at 01:25:15 PM PDT
//

package org.glassfish.connectors.config;

import com.sun.enterprise.config.serverbeans.Resource;
import com.sun.enterprise.config.serverbeans.ResourcePool;

import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;

import java.beans.PropertyVetoException;
import java.util.List;

import org.glassfish.admin.cli.resources.UniqueResourceNameConstraint;
import org.glassfish.api.admin.RestRedirect;
import org.glassfish.api.admin.RestRedirects;
import org.glassfish.api.admin.config.PropertiesDesc;
import org.glassfish.connectors.config.validators.ConnectionPoolConstraint;
import org.glassfish.connectors.config.validators.ConnectionPoolConstraints;
import org.glassfish.connectors.config.validators.ConnectionPoolErrorMessages;
import org.glassfish.quality.ToDo;
import org.glassfish.resourcebase.resources.ResourceDeploymentOrder;
import org.glassfish.resourcebase.resources.ResourceTypeOrder;
import org.jvnet.hk2.config.Attribute;
import org.jvnet.hk2.config.ConfigBeanProxy;
import org.jvnet.hk2.config.Configured;
import org.jvnet.hk2.config.Element;
import org.jvnet.hk2.config.types.Property;
import org.jvnet.hk2.config.types.PropertyBag;

/**
 * Defines configuration used to create and manage a pool of connections to an EIS.
 *
 * <p>>Pool definition is named, and can be referred  to by multiple connector-resource
 * elements (See {@code connector-resource}).
 *
 * <p>Each named pool definition results in a pool instantiated at server start-up.
 *
 * <p>Pool is populated when accessed for the first time. If two or more
 * connector-resource elements point to the same connector-connection-pool
 * element, they are using the same pool of connections, at run time
 *
 * <p>There can be more than one pool for one {@code connection-definition} in one
 * {@code resource-adapter}.
 */
@Configured
@ConnectionPoolConstraints({
        @ConnectionPoolConstraint(value = ConnectionPoolErrorMessages.MAX_STEADY_INVALID)
})
@RestRedirects({
        @RestRedirect(opType = RestRedirect.OpType.POST, commandName = "create-connector-connection-pool"),
        @RestRedirect(opType = RestRedirect.OpType.DELETE, commandName = "delete-connector-connection-pool")
})
@ResourceTypeOrder(deploymentOrder = ResourceDeploymentOrder.CONNECTOR_POOL)
@UniqueResourceNameConstraint(message = "{resourcename.isnot.unique}", payload = ConnectorConnectionPool.class)
public interface ConnectorConnectionPool extends ConfigBeanProxy, Resource, ResourcePool, PropertyBag {

    /**
     * Gets the value of the {@code resourceAdapterName} property.
     *
     * <p>This is the name of resource adapter. Name of .rar file is taken as the
     * unique name for the resource adapter.
     *
     * @return possible object is {@link String}
     */
    @Attribute
    @NotNull
    String getResourceAdapterName();

    /**
     * Sets the value of the {@code resourceAdapterName} property.
     *
     * @param raName allowed object is {@link String}
     */
    void setResourceAdapterName(String raName) throws PropertyVetoException;

    /**
     * Gets the value of the {@code connectionDefinitionName} property.
     *
     * <p>Unique name, identifying one connection-definition in a Resource Adapter.
     * Currently, this is {@code ConnectionFactory} type.
     *
     * @return possible object is {@link String}
     */
    @Attribute
    @NotNull
    String getConnectionDefinitionName();

    /**
     * Sets the value of the {@code connectionDefinitionName} property.
     *
     * @param definitionName allowed object is {@link String}
     */
    void setConnectionDefinitionName(String definitionName) throws PropertyVetoException;

    /**
     * Gets the value of the {@code steadyPoolSize} property.
     *
     * <p>Minimum and initial number of connections maintained in the pool.
     *
     * @return possible object is {@link String}
     */
    @Attribute (defaultValue = "8")
    @Min(value = 0)
    String getSteadyPoolSize();

    /**
     * Sets the value of the {@code steadyPoolSize} property.
     *
     * @param poolSize allowed object is {@link String}
     */
    void setSteadyPoolSize(String poolSize) throws PropertyVetoException;

    /**
     * Gets the value of the {@code maxPoolSize} property.
     *
     * <p>Maximum number of connections that can be created.
     *
     * @return possible object is {@link String}
     */
    @Attribute (defaultValue = "32")
    @Min(value = 1)
    String getMaxPoolSize();

    /**
     * Sets the value of the {@code maxPoolSize} property.
     *
     * @param maxPoolSize allowed object is {@link String}
     */
    void setMaxPoolSize(String maxPoolSize) throws PropertyVetoException;

    /**
     * Gets the value of the {@code maxWaitTimeInMillis} property.
     *
     * <p>Amount of time the caller will wait before getting a connection timeout.
     *
     * <p>The default is {@code 60} seconds.
     *
     * <p>A value of {@code 0} will force caller to wait indefinitely.
     *
     * @return possible object is {@link String}
     */
    @Attribute (defaultValue = "60000")
    @Min(value = 0)
    String getMaxWaitTimeInMillis();

    /**
     * Sets the value of the {@code maxWaitTimeInMillis} property.
     *
     * @param maxWaitTime allowed object is {@link String}
     */
    void setMaxWaitTimeInMillis(String maxWaitTime) throws PropertyVetoException;

    /**
     * Gets the value of the {@code poolResizeQuantity} property.
     *
     * <p>Number of connections to be removed when {@code idle-timeout-in-seconds}
     * timer expires. Connections that have idled for longer than the timeout are
     * candidates for removal. When the pool size reaches {@code steady-pool-size},
     * the connection removal stops.
     *
     * @return possible object is {@link String}
     */
    @Attribute (defaultValue = "2")
    @Min(value = 1)
    String getPoolResizeQuantity();

    /**
     * Sets the value of the {@code poolResizeQuantity} property.
     *
     * @param resizeQuantity allowed object is {@link String}
     */
    void setPoolResizeQuantity(String resizeQuantity) throws PropertyVetoException;

    /**
     * Gets the value of the {@code idleTimeoutInSeconds} property.
     *
     * <p>Maximum time in seconds, that a connection can remain idle in the pool.
     * After this time, the pool implementation can close this connection.
     *
     * <p>Note that this does not control connection timeouts enforced at the
     * database server side. Administrators are advised to keep this timeout
     * shorter than the EIS connection timeout (if such timeouts are configured
     * on the specific EIS), to prevent accumulation of unusable connection in
     * Application Server.
     *
     * @return possible object is {@link String}
     */
    @Attribute (defaultValue = "300")
    @Min(value = 1)
    @Max(value = Integer.MAX_VALUE)
    String getIdleTimeoutInSeconds();

    /**
     * Sets the value of the {@code idleTimeoutInSeconds} property.
     *
     * @param idleTimeout allowed object is {@link String}
     */
    void setIdleTimeoutInSeconds(String idleTimeout) throws PropertyVetoException;

    /**
     * Gets the value of the {@code failAllConnections} property.
     *
     * <p>Indicates if all connections in the pool must be closed should a single
     * connection fail validation.
     *
     * <p>The default is {@code false}. One attempt will be made to re-establish
     * failed connections.
     *
     * @return possible object is {@link String}
     */
    @Attribute (defaultValue = "false", dataType = Boolean.class)
    String getFailAllConnections();

    /**
     * Sets the value of the {@code failAllConnections} property.
     *
     * @param failAllConnections allowed object is {@link String}
     */
    void setFailAllConnections(String failAllConnections) throws PropertyVetoException;

    /**
     * Gets the value of the {@code transactionSupport} property.
     *
     * <p>Indicates the level of transaction support that this pool will have.
     * Possible values are:
     *
     * <ul>
     * <li>{@code XATransaction}</li>
     * <li>{@code LocalTransaction}</li>
     * <li>{@code NoTransaction}</li>
     * </ul>
     *
     * <p>This attribute will override that transaction support attribute in the
     * Resource Adapter in a downward compatible way, i.e. it can support a lower
     * or equal transaction level than specified in the RA, but not higher level
     *
     * @return possible object is {@link String}
     */
    @Attribute
    String getTransactionSupport();

    /**
     * Sets the value of the {@code transactionSupport} property.
     *
     * @param txSupport allowed object is {@link String}
     */
    void setTransactionSupport(String txSupport) throws PropertyVetoException;

    /**
     * Gets the value of the {@code isConnectionValidationRequired} property.
     *
     * <p>This attribute specifies if the connection that is about to be returned
     * is to be validated by the container.
     *
     * @return possible object is {@link String}
     */
    @Attribute (defaultValue = "false", dataType = Boolean.class)
    String getIsConnectionValidationRequired();

    /**
     * Sets the value of the {@code isConnectionValidationRequired} property.
     *
     * @param isValidationRequired allowed object is {@link String}
     */
    void setIsConnectionValidationRequired(String isValidationRequired) throws PropertyVetoException;

    /**
     * Gets the value of the {@code validateAtmostOncePeriodInSeconds} property.
     *
     * <p>Used to set the time-interval within which a connection is validated
     * atmost once.
     *
     * <p>Default is {@code 0} which implies that it is not enabled.
     *
     * @return possible object is {@link String}
     */
    @Attribute (defaultValue = "0")
    @Min(value = 0)
    String getValidateAtmostOncePeriodInSeconds();

    /**
     * Sets the value of the {@code validateAtmostOncePeriodInSeconds} property.
     *
     * @param validatePeriod allowed object is {@link String}
     */
    void setValidateAtmostOncePeriodInSeconds(String validatePeriod) throws PropertyVetoException;

    /**
     * Gets the value of the {@code connectionLeakTimeoutInSeconds} property.
     *
     * <p>To aid user in detecting potential connection leaks by the application.
     * When a connection is not returned back to the pool by the application
     * within the specified period, it is assumed to be a potential leak and
     * stack trace of the caller will be logged.
     *
     * <p>Default is {@code 0}, which implies there is no leak detection, by default.
     * A positive non-zero value turns on leak detection.
     *
     * <p>Note however that, this attribute only detects if there is a connection leak.
     * The connection can be reclaimed only if {@code connection-leak-reclaim} is set to true.
     *
     * @return possible object is {@link String}
     */
    @Attribute (defaultValue = "0")
    @Min(value = 0)
    String getConnectionLeakTimeoutInSeconds();

    /**
     * Sets the value of the {@code connectionLeakTimeoutInSeconds} property.
     *
     * @param leakTimeout allowed object is {@link String}
     */
    void setConnectionLeakTimeoutInSeconds(String leakTimeout) throws PropertyVetoException;

    /**
     * Gets the value of the {@code connectionLeakReclaim} property.
     *
     * <p>If enabled, connection will be reusable (put back into pool) after
     * {@code connection-leak-timeout-in-seconds} occurs.
     *
     * @return possible object is {@link String}
     */
    @Attribute (defaultValue = "false", dataType = Boolean.class)
    String getConnectionLeakReclaim();

    /**
     * Sets the value of the {@code connectionLeakReclaim} property.
     *
     * @param leakReclaim allowed object is {@link String}
     */
    void setConnectionLeakReclaim(String leakReclaim) throws PropertyVetoException;

    /**
     * Gets the value of the {@code connectionCreationRetryAttempts} property.
     *
     * <p>The number of attempts to create a new connection.
     *
     * <p>Default is {@code 0}, which implies no retries.
     *
     * @return possible object is {@link String}
     */
    @Attribute (defaultValue = "0")
    String getConnectionCreationRetryAttempts();

    /**
     * Sets the value of the {@code connectionCreationRetryAttempts} property.
     *
     * @param retryAttempts allowed object is {@link String}
     */
    void setConnectionCreationRetryAttempts(String retryAttempts) throws PropertyVetoException;

    /**
     * Gets the value of the {@code connectionCreationRetryIntervalInSeconds} property.
     *
     * <p>The time interval between retries while attempting to create a connection
     *
     * <p>Default is {@code 10} seconds.
     *
     * <p>Effective when {@code connection-creation-retry-attempts} is greater than 0.
     *
     * @return possible object is {@link String}
     */
    @Attribute (defaultValue = "10")
    String getConnectionCreationRetryIntervalInSeconds();

    /**
     * Sets the value of the {@code connectionCreationRetryIntervalInSeconds} property.
     *
     * @param retryInterval allowed object is {@link String}
     */
    void setConnectionCreationRetryIntervalInSeconds(String retryInterval) throws PropertyVetoException;

    /**
     * Gets the value of the {@code lazyConnectionEnlistment} property.
     *
     * <p>Enlist a resource to the transaction only when it is actually used in a
     * method, which avoids enlistment of connections that are not used in a
     * transaction. This also prevents unnecessary enlistment of connections
     * cached in the calling components.
     *
     * <p>Default value is {@code false}.
     *
     * @return possible object is {@link String}
     */
    @Attribute (defaultValue = "false", dataType = Boolean.class)
    String getLazyConnectionEnlistment();

    /**
     * Sets the value of the {@code lazyConnectionEnlistment} property.
     *
     * @param lazyEnlistment allowed object is {@link String}
     */
    void setLazyConnectionEnlistment(String lazyEnlistment) throws PropertyVetoException;

    /**
     * Gets the value of the {@code lazyConnectionAssociation} property.
     *
     * <p>Connections are lazily associated when an operation is performed on them.
     * Also, they are disassociated when the transaction is completed and a
     * component method ends, which helps reuse of the physical connections.
     *
     * <p>Default value is {@code false}.
     *
     * @return possible object is {@link String}
     */
    @Attribute (defaultValue = "false", dataType = Boolean.class)
    String getLazyConnectionAssociation();

    /**
     * Sets the value of the {@code lazyConnectionAssociation} property.
     *
     * @param lazyAssociation allowed object is {@link String}
     */
    void setLazyConnectionAssociation(String lazyAssociation) throws PropertyVetoException;

    /**
     * Gets the value of the {@code associateWithThread} property.
     *
     * <p>Associate a connection with the thread such that when the same thread is
     * in need of a connection, it can reuse the connection already associated
     * with that thread, thereby not incurring the overhead of getting a
     * connection from the pool.
     *
     * @return possible object is {@link String}
     */
    @Attribute (defaultValue = "false", dataType = Boolean.class)
    String getAssociateWithThread();

    /**
     * Sets the value of the {@code associateWithThread} property.
     *
     * @param associateWithThread allowed object is {@link String}
     */
    void setAssociateWithThread(String associateWithThread) throws PropertyVetoException;

    /**
     * Gets the value of the {@code pooling} property.
     *
     * <p>Property to disable pooling for the pool.
     *
     * @return possible object is {@link String}
     */
    @Attribute (defaultValue = "true", dataType = Boolean.class)
    String getPooling();

    /**
     * Sets the value of the {@code pooling} property.
     *
     * @param pooling allowed object is {@link String}
     */
    void setPooling(String pooling) throws PropertyVetoException;

    /**
     * Gets the value of the {@code matchConnections} property.
     *
     * <p>To switch on/off connection matching for the pool. It can be set to false
     * if the administrator knows that the connections in the pool will always
     * be homogeneous and hence a connection picked from the pool need not be
     * matched by the resource adapter.
     *
     * <p>Default value is {@code true}.
     *
     * @return possible object is {@link String}
     */
    @Attribute (defaultValue = "true", dataType = Boolean.class)
    String getMatchConnections();

    /**
     * Sets the value of the {@code matchConnections} property.
     *
     * @param matchConnections allowed object is {@link String}
     */
    void setMatchConnections(String matchConnections) throws PropertyVetoException;

    /**
     * Gets the value of the {@code maxConnectionUsageCount} property.
     *
     * <p>When specified, connections will be re-used by the pool for the specified
     * number of times after which it will be closed. This is useful for
     * instance, to avoid statement-leaks.
     *
     * <p>Default value is {@code 0}, which implies the feature is not enabled.
     *
     * @return possible object is {@link String}
     */
    @Attribute (defaultValue = "0")
    @Min(value = 0)
    @Max(value = Integer.MAX_VALUE)
    String getMaxConnectionUsageCount();

    /**
     * Sets the value of the {@code maxConnectionUsageCount} property.
     *
     * @param maxUsageCount allowed object is {@link String}
     */
    void setMaxConnectionUsageCount(String maxUsageCount) throws PropertyVetoException;

    /**
     * Gets the value of the {@code description} property.
     *
     * @return possible object is {@link String}
     */
    @Attribute
    String getDescription();

    /**
     * Sets the value of the {@code description} property.
     *
     * @param description allowed object is {@link String}
     */
    void setDescription(String description) throws PropertyVetoException;

    /**
     * Gets the value of the {@code securityMap} property.
     *
     * <p>This accessor method returns a reference to the live list, not a snapshot.
     * Therefore any modification you make to the returned list will be present inside
     * the JAXB object. This is why there is not a {@code set} method for the
     * {@code securityMap} property.
     *
     * <p>For example, to add a new item, do as follows:
     *
     * <pre>
     *    getSecurityMap().add(newItem);
     * </pre>
     *
     * <p>Objects of the following type(s) are allowed in the list {@link SecurityMap}
     */
    @Element
    @NotNull
    List<SecurityMap> getSecurityMap();

    /**
     * Properties as per {@link org.jvnet.hk2.config.types.PropertyBag}
     *
     * <p>Properties are used to override the {@code ManagedConnectionFactory} javabean
     * configuration settings. When one or more of these properties are specified,
     * they are passed as is using {@literal set<Name>(<Value>)} methods to the
     * Resource Adapter's {@code ManagedConnectionfactory} class (specified in {@code ra.xml}).
     */
    @ToDo(priority = ToDo.Priority.IMPORTANT, details = "Provide PropertyDesc for legal props" )
    @PropertiesDesc(props = {})
    @Element
    List<Property> getProperty();

    default String getIdentity() {
        return getName();
    }
}
